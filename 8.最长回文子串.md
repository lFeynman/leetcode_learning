## 8.最长回文子串

### 原题链接:https://leetcode.cn/leetbook/read/array-and-string/conm7/

**题目描述:**

```
给你一个字符串 s，找到 s 中最长的 回文 子串。
```

**思路:**

```
中心扩展法:回文子串分为两种,奇数子串,偶数子串,同时遍历每个i的奇数和偶数子串,不断更新始末位置索引
Manacher算法:给每个字前后添加#,字符串始末位置添加^和$以防越界,一个回文子串想象为一个蘑菇,蘑菇覆盖内的子串对称,如果超出边界部分,则取到边界或者对称点蘑菇大小的最小值,不断尝试更新
```

**代码:**

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        start=end=0 # 始末位置索引
        def expand_around_center(left:int,right:int)->tuple:
            while left>=0 and right<len(s) and s[left]==s[right]:
                left-=1
                right+=1
            return (left+1,right-1)
        for i in range(len(s)):
            l1,r1=expand_around_center(i,i)
            l2,r2=expand_around_center(i,i+1)
            if r1-l1>end-start:
                end,start=r1,l1
            if r2-l2>end-start:
                end,start=r2,l2
        return s[start:end+1]
#Manacher算法:
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""
        start=end=0 # 始末位置索引
        T='^#'+'#'.join(s)+'#$'
        n=len(T)
        P=[0]*n#初始化P数组,P[i]是以T[i]为中心的最长回文半径
        C=R=0 #C表示最右回文的中心,R表示最右的边界
        for i in range(1,n-1):
            if i<R:#在边界内
                P[i]=min(R-i,P[2*C-i])#取对称点半径和到边界距离的最小值
            # 尝试扩展
            while T[i+P[i]+1]==T[i-P[i]-1]:
                P[i]+=1
            if i+P[i]>R:
                C,R=i,i+P[i]
        max_len,center_idx=max((val,idx) for idx,val in enumerate(P))
        start=(center_idx-max_len)//2
        return s[start:start+max_len]
```

